Postgres Recipies

#+begin_src emacs-lispf
(defun indent-org-block-automatically ()
  (when (org-in-src-block-p)
   (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit)))

(run-at-time 1 10 'indent-org-block-automatically)
#+end_src 

* What are the various data models that are possible with Postgres?
** 3NF transaction model
** Star schemas for DataMart
** EAVT like datamoic
** document like MongoDB
** Graph 
** Trees
<2020-01-31 Fri>

** EAVT
#+begin_src sql
  CREATE TABLE test(
  id serial PRIMARY KEY,
  data jsonb,
  ts timestamp DEFAULT clock_timestamp()
  );

  INSERT INTO test values (DEFAULT, $$ {"e": 1, "a": "name", "v": "swaroop" "t": "monotonically increasing tx"}$$, DEFAULT);

#+end_src

Another model

#+begin_src sql

CREATE TABLE entity (
  id serial PRIMARY KEY,
  kind text,
  data jsonb,
  is_retracted boolean,
  ts timestamp
);
CREATE TABLE entity_rltp (
  from_id int NOT NULL references entity(id),
  to_id int NOT NULL references entity(id),
  kind text,
  data jsonb,
  is_retracted boolean,
  ts timestamp
);

#+end_src
** Others

#+begin_src sql

  CREATE TABLE IF NOT EXISTS files (
  id int GENERATED ALWAYS AS IDENTITY,
  body jsonb,
  updated_at timestamptz DEFAULT now(),
  PRIMARY KEY (id)
  );

  INSERT INTO files values DEFAULT, $${}$$, DEFAULT) RETURNING *;

  WITH get_files_by_hash AS (
  SELECT id, body, updated_at FROM files WHERE id=1
  )
  SELECT body from get_files_by_hash;

#+end_src 

* Piplelines with CTE

WITH deleting_files AS (DELETE FROM files RETURNING *)
INSERT INTO archive_files SELECT * FROM deleting_files;

* WITH RECURSIVE

CREATE TABLE employees
(id int PRIMARY KEY, 
 mgr_id int REFERENCES employees (id),
 name text
);

INSERT INTO employees VALUES 
(1,NULL,'CEO'),
(2,1,'CFO'),
(3,1,'CTO'),
(4,1,'CIO'),
(5,1,'CMO'),
(6,1,'CRO'),
(7,1,'CHRO'),
(8,3,'VP - Engineering'),
(9,3,'VP - Product Management'),
(10,3,'VP - Design')
;

WITH RECURSIVE emp_org AS (
  SELECT name, id FROM employees WHERE mgr_id IS NULL
  UNION
  SELECT e.name || ' > ' || eo.name, eo.id
  FROM employees e
  JOIN emp_org eo ON eo.id = e.mgr_id
)
SELECT name FROM emp_org ORDER BY name
;


* PL/PGSQL

You can execute pl/pgsql from psql as

DO $$
BEGIN
 RAISE INFO '1 + 2 = %', (1+2);
END
$$;


#+BEGIN_SRC sql
DO $code$
DECLARE
  i int; -- initial value is NULL
  t text := 'Hello World!';
  d date := CURRENT_DATE;
BEGIN
  RAISE INFO 'Variables are: d = [%], t = [%], i = [%]', d, t, i;
  i := length( t );
  d := now(); -- coerced to 'date'
  SELECT 'Happy new ' || EXTRACT( year FROM d ) + 1 || ' year!', i * i
  INTO t, i;
  RAISE INFO 'Variables now are: d = [%], t = [%], i = [%]', d, t, i;
END $code$;

#+END_SRC

#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION addition (integer, integer) RETURNS integer
AS $$
DECLARE retval integer;
BEGIN
  SELECT $1 + $2 INTO retval;
  RETURN retval;
END;
$$ LANGUAGE plpgsql;
#+END_SRC

* Want to load CSV file?
Do you have a log file in CSV format to load into a table? Or do you have some list of employees excel file to load?

Use FDW (file_fdw) to load it quickly

#+begin_src sql
CREATE EXTENSION file_fdw;
CREATE SERVER file_server FOREIGN DATA WRAPPER file_fdw;

$ cat testdata.csv
AARON, ELVIA J|WATER RATE TAKER|WATER MGMNT|81000.00|73862.00
AARON, JEFFERY M|POLICE OFFICER|POLICE|74628.00|74628.00
AARON, KIMBERLEI R|CHIEF CONTRACT EXPEDITER|FLEET
MANAGEMNT|77280.00|70174.00

CREATE FOREIGN TABLE employee (
  emp_name VARCHAR,
  job_title VARCHAR,
  dept VARCHAR,
  salary NUMERIC,
  sal_after_tax NUMERIC
) SERVER file_server
OPTIONS (format 'csv', header 'false', filename '/home/pgbook/14/testdata.csv', delimiter '|', null '');'')
;

SELECT * from employee;
\d employee;
EXPLAIN SELECT * FROM employee WHERE salary > 5000;

#+end_src

* How to create an aggregate in server-side postgres?
(saving from bringing all the data into client-side and looping over)

#+begin_src sql
CREATE FUNCTION _final_median(anyarray) RETURNS float8 AS $$
WITH q AS
(
SELECT val
FROM unnest($1) val
WHERE VAL IS NOT NULL
ORDER BY 1
),
cnt AS
(
SELECT COUNT(*) AS c FROM q
)
SELECT AVG(val)::float8
FROM
(
SELECT val FROM q
LIMIT 2 - MOD((SELECT c FROM cnt), 2)
) q2;
$$ LANGUAGE sql IMMUTABLE;

CREATE AGGREGATE median(anyelement) (
SFUNC=array_append,
STYPE=anyarray,
FINALFUNC=_final_median,
INITCOND='{}'
);

CREATE TABLE median_test(t integer);

INSERT INTO median_test SELECT generate_series(1,10);

SELECT median(t) FROM median_test;
#+end_src

* How to index new types?
  If you have SSNs like 111-11-98989, 222-22-98988 etc. and you want to sort them by last 5 digits

#+begin_src sql
CREATE TABLE test_ssn (ssn text);
INSERT INTO test_ssn VALUES ('222-11-020878');
INSERT INTO test_ssn VALUES ('111-11-020978');

-- function to remove hyphens
CREATE OR REPLACE FUNCTION fix_ssn(text)
RETURNS text AS $$
BEGIN
RETURN substring($1,8) || replace(substring($1,1,7),'-','');
END;
$$LANGUAGE 'plpgsql' IMMUTABLE;

SELECT fix_ssn(ssn) FROM test_ssn;

CREATE OR REPLACE FUNCTION ssn_compareTo(text, text)
RETURNS int AS
$$
BEGIN
IF fix_ssn($1) < fix_ssn($2)
THEN
RETURN -1;
ELSIF fix_ssn($1) > fix_ssn($2)
THEN
RETURN +1;
ELSE
RETURN 0;
END IF;
END;
$$ LANGUAGE 'plpgsql' IMMUTABLE;

CREATE OPERATOR CLASS ssn_ops
FOR TYPE text USING btree
AS
OPERATOR 1 < ,
OPERATOR 2 <= ,
OPERATOR 3 = ,
OPERATOR 4 >= ,
OPERATOR 5 > ,
FUNCTION 1 ssn_compareTo(text, text);

CREATE INDEX idx_ssn ON test_ssn (ssn ssn_ops);

-- We can check whether the optimizer is willing to use our special index, as follows:
SET enable_seqscan=off;
EXPLAIN SELECT * FROM test_ssn WHERE ssn = '02087822211';
#+end_src

* How to shard database a.k.a as Horizontal Scaling
When one server + one or two hot standby servers are not enough?  ie. You are in good business and thriving. You might even have a lot of money to throw at this pesky database problem. You may be thinking of a NoSQL database also?

Even if you don't have a thriving businss and are just loading lots of  log files into database

What are the poor man's solutions to this problem? Data partitioning across multiple servers.


Let us first create a high data problem for us.

#+begin_src sql

  CREATE TABLE user_info (
  username text primary key,
  pwdhash text not null, —base64 encoded md5 hash of password
  email text,
  friend_list text[],—list of buddies usernames
  friends_only boolean not null default false
  );

  CREATE TABLE message (
  from_user text not null references user_info(username),
  sent_at timestamp not null default current_timestamp,
  to_user text not null references user_info(username),
  read_at timestamp,—when was this retrieved by to_user
  msg_body text not null,
  delivery_status text not null default 'outgoing'— ('sent', "failed")
  );

  -- create user
  CREATE or REPLACE FUNCTION new_user(
  IN i_username text, IN i_pwdhash text, IN i_email text,
  OUT status int, OUT message text )
  AS $$
  BEGIN
  INSERT INTO user_info( username, pwdhash, email)
  VALUES ( i_username, i_pwdhash, i_email);
  status = 200;
  message = 'OK';
  EXCEPTION WHEN unique_violation THEN
  status = 500;
  message = 'USER EXISTS';
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE OR REPLACE FUNCTION login(
  IN i_username text, IN i_pwdhash text,
  OUT status int, OUT message text )
  AS $$
  BEGIN
  PERFORM 1 FROM user_info
  WHERE ( username, pwdhash) = ( i_username, i_pwdhash);
  IF NOT FOUND THEN
  status = 500;
  message = 'NOT FOUND';
  return;
  END IF;
  PERFORM 1 FROM message
  WHERE to_user = i_username
  AND read_at IS NULL;
  IF FOUND THEN
  status = 201;
  message = 'OK. NEW MESSAGES';
  ELSE
  status = 200;
  message = 'OK. NO MESSAGES';
  END IF;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE or REPLACE FUNCTION set_friends_list(
  IN i_username text, IN i_friends_list text[],
  OUT status int, OUT message text )
  AS $$
  BEGIN
  UPDATE user_info
  SET friend_list = i_friends_list
  WHERE username = i_username;
  status = 200;
  message = 'OK';
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE or REPLACE FUNCTION msg_from_friends_only(
  IN i_username text, IN i_friends_only boolean,OUT status int, OUT
  message text )
  AS $$
  BEGIN
  UPDATE user_info SET friends_only = i_friends_only
  WHERE username = i_username;
  status = 200;
  message = 'OK';
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE or REPLACE FUNCTION send_message(
  IN i_from_user text, IN i_to_user text, IN i_message text,
  OUT status int, OUT message text )
  AS $$
  BEGIN
  PERFORM 1 FROM user_info
  WHERE username = i_to_user
  AND (NOT friends_only OR friend_list @> ARRAY[i_from_user]);
  IF NOT FOUND THEN
  status = 400;
  message = 'SENDING FAILED';
  RETURN;
  END IF;
  INSERT INTO message(from_user, to_user, msg_body, delivery_status)
  VALUES (i_from_user, i_to_user, i_message, 'sent');
  status = 200;
  message = 'OK';
  EXCEPTION
  WHEN foreign_key_violation THEN
  status = 500;
  message = 'FAILED';
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  CREATE or REPLACE FUNCTION get_new_messages(
  IN i_username text,
  OUT o_status int, OUT o_message_text text,
  OUT o_from_user text, OUT o_sent_at timestamp)
  RETURNS SETOF RECORD
  AS $$
  BEGIN
  FOR o_status, o_message_text, o_from_user, o_sent_at IN
  UPDATE message
  SET read_at = CURRENT_TIMESTAMP,
  delivery_status = 'read'
  WHERE to_user = i_username AND read_at IS NULL
  RETURNING 200, msg_body, from_user , sent_at
  LOOP
  RETURN NEXT;
  END LOOP;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  SELECT new_user(generate_series::text, 'pwd', generate_series::text || '@pg.org')
  FROM generate_series(1,100000);

  WITH ns(n,len) AS (
  SELECT *,(random() * 10)::int FROM generate_series(1,100000)
  )
  SELECT set_friends_list(ns.n::text, ARRAY( (SELECT (random() * 100000)::int FROM generate_series(1,len)) )::text[])
  FROM ns;

  SELECT count(*) FROM (SELECT username,unnest(friend_list) FROM user_info) a;

  SELECT send_message(username,unnest(friend_list),'hello friend!')
  FROM user_info;

  SELECT get_new_messages('50000');

  CREATE INDEX message_from_user_ndx ON message(from_user);
  CREATE INDEX message_to_user_ndx ON message(to_user);

  SELECT get_new_messages('52000');

  ALTER TABLE message SET (fillfactor = 90);
  CLUSTER message_from_user_ndx ON message;

#+end_src


The partitioning function for selecting between four servers would be simply partition_nr = id & 3
The partitioning mask 3 (binary 11) is for the first two bits. For eight partitions, you would
use 7 (binary 111), and for 64 servers it would be 63 (00111111). It is not as easy with
things like usernames, where putting all names starting with an A first, B second, and so
on, does not produce an even distribution.

partition_nr = hashtext(username) & 3

PL/Proxy - for partitioning servers agostic proxy
pgbouncer/pgpool - for connection pooling

Pl/Proxy is old solution this problem.  Postgres since has acquired replication features and this problem can be solved in better way.  Hence leaving it here.

#+begin_src sql

  SELECT username, hashtext(username) & 3 as partition_nr FROM user_info;

#+end_src

* Would you like to write postgres functions in python?  Do you fancy availing  all the python power?

Python2 or Python3?

#+begin_src sql
  CREATE LANGUAGE plpythonu;

  CREATE FUNCTION gethostbyname(hostname text)
  RETURNS inet
  AS $$
  import socket
  return socket.gethostbyname(hostname)
  $$ LANGUAGE plpythonu SECURITY DEFINER;

  SELECT gethostbyname('www.postgresql.org');

  CREATE FUNCTION hello(name text)
  RETURNS text
  AS $$
  return 'hello %s !' % name
  $$ LANGUAGE plpythonu;

#+end_src



